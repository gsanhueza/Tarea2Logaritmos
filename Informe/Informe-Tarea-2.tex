\documentclass[letterpaper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{fontenc}
\usepackage[dvipdfmx]{graphicx}
\usepackage{bmpsize,wrapfig,xcolor}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage[hidelinks]{hyperref}

% Para evitar que se indente solo a cada rato
\setlength\parindent{0pt}

\begin{document}
	\begin{titlepage}

		\begin{wrapfigure}{R}{0.3\textwidth}
			\includegraphics[width=0.3\textwidth]{logoFCFM.png}
		\end{wrapfigure}

		\noindent \phantom - % "Hax" para que quede alineada la imagen con el texto

		Universidad de Chile

		Facultad de Ciencias Físicas y Matemáticas

		Depto. de Ciencias de la Computación

		CC4102 - Diseño y Análisis de Algoritmos

		\vfill

		\begin{center}
			\begin{Huge}
				{\textbf{Tarea 2}}
			\end{Huge}
		\end{center}

		\vfill

		\begin{flushright}
			\begin{tabular}{lll}
				Integrantes	&:	& Rodrigo Delgado\\
						&	& Belisario Panay\\
						&	& Gabriel Sanhueza\\
				Profesor	&:	& Gonzalo Navarro\\
				Ayudantes	&:	& Sebastián Ferrada\\
						&	& Willy Maikowski\\
				Auxiliar	&:	& Jorge Bahamondes\\
			\end{tabular}
		\end{flushright}

	\end{titlepage}

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\tableofcontents

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Introducción}

	// TODO: Definir qué es un suffix tree

	// TODO: Decir que queremos probar Ukkonen, y que es Ukkonen
	%% fix esto es como blabla pero no deberia ir aca xD %%

	Se pide que plantee una hipótesis con respecto al tiempo amortizado de construcción de una estructura de este
	tipo y al tiempo de búsqueda, y la ponga a prueba de forma experimental.
	Se espera que se implemente la estructura y los algoritmos correspondientes, y se entregue un informe.
	En el presente informe se muestra el diseño, implementación y experimentación para resolver la Tarea 2 del curso CC4102 Diseño y Análisis de Algoritmos de la carrera de ingeniería
	civil en Computación de la Universidad de Chile, la cual consiste en programar un algoritmo de orden lineal para la creación de Suffix Trees, una estructura de datos de datos del tipo Arbol,
	la que esta formada por Nodos que poseen información interna y referencias a sus hijo. En particular el SuffixTree almacena los sufijos de un string en forma de arbol, de modo que cada arco
	contiene los caracteres para formar una palabra, si se llega a una hoja ( nodo terminal ) es porque recorrimos los arcos necesarios para formar un sufijo. La idea de la tarea es que el
	algoritmo a desarrollar es on-line, de orden lineal y con una implementación mas sencilla con respecto a algoritmos similares ( algoritmo de Weiner y algoritmo de McCreight ).

	\subsection{Problema a resolver}
	%% Se puede rellenar mas aca%%
	// TODO: Explicar que queremos desarrollar un suffix tree para acelerar busqueda de texto

	// TODO: Decir que queremos que sea rápido

	El problema consiste en realizar los pasos necesarios para la buena implementación del algoritmo, ya que pequeños errores en código pueden producir un algoritmo de mayor orden de magnitud
	y con ello se falla en el objetivo. Los pasos para realizarlos estan detallados en el enunciado de la tarea y son los pasos que se desarrollan en el paper del algoritmo de ukkonen, el cual
	se encuentra disponible en el enunciado de la tarea. Como resumen, se puede detallar que los pasos consisten en pasar un algoritmo de Orden n³ a orden lineal.

	\subsection{Hipótesis}

	// TODO: Decir que creemos que Ukkonen será más rápido que un suffix tree normal, probablemente será lineal
	%% por tener alguna (?)%%
	Si bien es un algoritmo lineal, el algoritmo posee una constante que hace que el tiempo pueda crecer de manera rapida, tambien como el algoritmo será escrito en java como lenguaje,
	posee caracteristicas como el garbage collector que reducen la eficiencia del algoritmo al tomar la Cpu para hacer realizar sus funciones. Se espera demostrar que la constante del algoritmo
	varía con respecto al largo por motivos externos al algoritmo, esto se puede mostrar si para números pequeños el agoritmo si demuestra un comportamiento lineal.

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %


	\section{Diseño Teórico}

	// TODO: Mostrar las distintas clases creadas y para qué sirven (cada clase puede tener su propia subsection)

	Para explicar el diseño teórico del algoritmo primero se deben definir algunos conceptos:
	\begin{itemize}
		\item Suffix Tree Implicit es un Suffix Tree al cual se le remueven sus simbolos terminales ( en algunos casos se utiliza el signo \$ como terminal)
	\end{itemize}

	\subsection{Metodología}

	\subsection{Structs}

	\subsubsection{Rectangle?}

	\subsubsection{Node}

	\subsection{Constantes}

	\subsection{Funciones}

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Presentación de los Resultados}

	\subsection{Tiempo de Creación del Suffix Tree}

	// TODO: Mostrar cuanto se tarda en crear un suffix tree, para N = 2 ** 15..21 palabras (aprox).

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\subsection{Desempeño de operación \textit{Buscar}}

	// TODO: Mostrar cuanto se demora en buscar N = (2 ** 15..21) / 10 palabras (aprox).

	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
	\newpage
	% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

	\section{Análisis y Conclusiones}

	\subsection{Construcción del Suffix Tree}

	// TODO: Verificar si el Suffix tree fue lineal o no

	\subsection{Búsqueda en el Suffix Tree}

	// TODO: Verificar si los tiempos están acotados o se fueron a la chu*** cada vez que aumentamos el número

	\subsection{Conclusiones}

	// TODO: Resumir lo ``aprendido'' (?)

\end{document}
